// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_BALANCEBOT_BALANCEBOTFLATBUFFERS_H_
#define FLATBUFFERS_GENERATED_BALANCEBOT_BALANCEBOTFLATBUFFERS_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

namespace BalanceBotFlatbuffers {

struct PitchPID;

struct PitchPIDState;

struct PitchController;
struct PitchControllerBuilder;

struct YawPID;

struct YawPIDState;

struct YawController;
struct YawControllerBuilder;

struct PhysicalCharacteristics;
struct PhysicalCharacteristicsBuilder;

struct MotorConfig;
struct MotorConfigBuilder;

struct Drive;

struct Web2Bot;
struct Web2BotBuilder;

struct MotorState;

struct RobotState;
struct RobotStateBuilder;

struct Bot2Web;
struct Bot2WebBuilder;

enum PitchControllerType : int8_t {
  PitchControllerType_PID = 0,
  PitchControllerType_MIN = PitchControllerType_PID,
  PitchControllerType_MAX = PitchControllerType_PID
};

inline const PitchControllerType (&EnumValuesPitchControllerType())[1] {
  static const PitchControllerType values[] = {
    PitchControllerType_PID
  };
  return values;
}

inline const char * const *EnumNamesPitchControllerType() {
  static const char * const names[2] = {
    "PID",
    nullptr
  };
  return names;
}

inline const char *EnumNamePitchControllerType(PitchControllerType e) {
  if (::flatbuffers::IsOutRange(e, PitchControllerType_PID, PitchControllerType_PID)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPitchControllerType()[index];
}

enum PitchControllerState : uint8_t {
  PitchControllerState_NONE = 0,
  PitchControllerState_PID = 1,
  PitchControllerState_MIN = PitchControllerState_NONE,
  PitchControllerState_MAX = PitchControllerState_PID
};

inline const PitchControllerState (&EnumValuesPitchControllerState())[2] {
  static const PitchControllerState values[] = {
    PitchControllerState_NONE,
    PitchControllerState_PID
  };
  return values;
}

inline const char * const *EnumNamesPitchControllerState() {
  static const char * const names[3] = {
    "NONE",
    "PID",
    nullptr
  };
  return names;
}

inline const char *EnumNamePitchControllerState(PitchControllerState e) {
  if (::flatbuffers::IsOutRange(e, PitchControllerState_NONE, PitchControllerState_PID)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPitchControllerState()[index];
}

template<typename T> struct PitchControllerStateTraits {
  static const PitchControllerState enum_value = PitchControllerState_NONE;
};

template<> struct PitchControllerStateTraits<BalanceBotFlatbuffers::PitchPIDState> {
  static const PitchControllerState enum_value = PitchControllerState_PID;
};

bool VerifyPitchControllerState(::flatbuffers::Verifier &verifier, const void *obj, PitchControllerState type);
bool VerifyPitchControllerStateVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

enum YawControllerType : int8_t {
  YawControllerType_PID = 0,
  YawControllerType_MIN = YawControllerType_PID,
  YawControllerType_MAX = YawControllerType_PID
};

inline const YawControllerType (&EnumValuesYawControllerType())[1] {
  static const YawControllerType values[] = {
    YawControllerType_PID
  };
  return values;
}

inline const char * const *EnumNamesYawControllerType() {
  static const char * const names[2] = {
    "PID",
    nullptr
  };
  return names;
}

inline const char *EnumNameYawControllerType(YawControllerType e) {
  if (::flatbuffers::IsOutRange(e, YawControllerType_PID, YawControllerType_PID)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesYawControllerType()[index];
}

enum YawControllerState : uint8_t {
  YawControllerState_NONE = 0,
  YawControllerState_PID = 1,
  YawControllerState_MIN = YawControllerState_NONE,
  YawControllerState_MAX = YawControllerState_PID
};

inline const YawControllerState (&EnumValuesYawControllerState())[2] {
  static const YawControllerState values[] = {
    YawControllerState_NONE,
    YawControllerState_PID
  };
  return values;
}

inline const char * const *EnumNamesYawControllerState() {
  static const char * const names[3] = {
    "NONE",
    "PID",
    nullptr
  };
  return names;
}

inline const char *EnumNameYawControllerState(YawControllerState e) {
  if (::flatbuffers::IsOutRange(e, YawControllerState_NONE, YawControllerState_PID)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesYawControllerState()[index];
}

template<typename T> struct YawControllerStateTraits {
  static const YawControllerState enum_value = YawControllerState_NONE;
};

template<> struct YawControllerStateTraits<BalanceBotFlatbuffers::YawPIDState> {
  static const YawControllerState enum_value = YawControllerState_PID;
};

bool VerifyYawControllerState(::flatbuffers::Verifier &verifier, const void *obj, YawControllerState type);
bool VerifyYawControllerStateVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) PitchPID FLATBUFFERS_FINAL_CLASS {
 private:
  float kp_;
  float ki_;
  float kd_;
  float integral_zero_threshold_;
  float integral_saturation_limit_;
  uint8_t reset_integral_;
  uint8_t add_gravity_;
  int16_t padding0__;

 public:
  PitchPID()
      : kp_(0),
        ki_(0),
        kd_(0),
        integral_zero_threshold_(0),
        integral_saturation_limit_(0),
        reset_integral_(0),
        add_gravity_(0),
        padding0__(0) {
    (void)padding0__;
  }
  PitchPID(float _kp, float _ki, float _kd, float _integral_zero_threshold, float _integral_saturation_limit, bool _reset_integral, bool _add_gravity)
      : kp_(::flatbuffers::EndianScalar(_kp)),
        ki_(::flatbuffers::EndianScalar(_ki)),
        kd_(::flatbuffers::EndianScalar(_kd)),
        integral_zero_threshold_(::flatbuffers::EndianScalar(_integral_zero_threshold)),
        integral_saturation_limit_(::flatbuffers::EndianScalar(_integral_saturation_limit)),
        reset_integral_(::flatbuffers::EndianScalar(static_cast<uint8_t>(_reset_integral))),
        add_gravity_(::flatbuffers::EndianScalar(static_cast<uint8_t>(_add_gravity))),
        padding0__(0) {
    (void)padding0__;
  }
  float kp() const {
    return ::flatbuffers::EndianScalar(kp_);
  }
  float ki() const {
    return ::flatbuffers::EndianScalar(ki_);
  }
  float kd() const {
    return ::flatbuffers::EndianScalar(kd_);
  }
  float integral_zero_threshold() const {
    return ::flatbuffers::EndianScalar(integral_zero_threshold_);
  }
  float integral_saturation_limit() const {
    return ::flatbuffers::EndianScalar(integral_saturation_limit_);
  }
  bool reset_integral() const {
    return ::flatbuffers::EndianScalar(reset_integral_) != 0;
  }
  bool add_gravity() const {
    return ::flatbuffers::EndianScalar(add_gravity_) != 0;
  }
};
FLATBUFFERS_STRUCT_END(PitchPID, 24);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) PitchPIDState FLATBUFFERS_FINAL_CLASS {
 private:
  float error_;
  float integral_;
  float derivative_;
  float output_;
  float saturated_;

 public:
  PitchPIDState()
      : error_(0),
        integral_(0),
        derivative_(0),
        output_(0),
        saturated_(0) {
  }
  PitchPIDState(float _error, float _integral, float _derivative, float _output, float _saturated)
      : error_(::flatbuffers::EndianScalar(_error)),
        integral_(::flatbuffers::EndianScalar(_integral)),
        derivative_(::flatbuffers::EndianScalar(_derivative)),
        output_(::flatbuffers::EndianScalar(_output)),
        saturated_(::flatbuffers::EndianScalar(_saturated)) {
  }
  float error() const {
    return ::flatbuffers::EndianScalar(error_);
  }
  float integral() const {
    return ::flatbuffers::EndianScalar(integral_);
  }
  float derivative() const {
    return ::flatbuffers::EndianScalar(derivative_);
  }
  float output() const {
    return ::flatbuffers::EndianScalar(output_);
  }
  float saturated() const {
    return ::flatbuffers::EndianScalar(saturated_);
  }
};
FLATBUFFERS_STRUCT_END(PitchPIDState, 20);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) YawPID FLATBUFFERS_FINAL_CLASS {
 private:
  float kp_;
  float ki_;
  float kd_;
  float integral_zero_threshold_;
  float integral_saturation_limit_;
  uint8_t reset_integral_;
  int8_t padding0__;  int16_t padding1__;

 public:
  YawPID()
      : kp_(0),
        ki_(0),
        kd_(0),
        integral_zero_threshold_(0),
        integral_saturation_limit_(0),
        reset_integral_(0),
        padding0__(0),
        padding1__(0) {
    (void)padding0__;
    (void)padding1__;
  }
  YawPID(float _kp, float _ki, float _kd, float _integral_zero_threshold, float _integral_saturation_limit, bool _reset_integral)
      : kp_(::flatbuffers::EndianScalar(_kp)),
        ki_(::flatbuffers::EndianScalar(_ki)),
        kd_(::flatbuffers::EndianScalar(_kd)),
        integral_zero_threshold_(::flatbuffers::EndianScalar(_integral_zero_threshold)),
        integral_saturation_limit_(::flatbuffers::EndianScalar(_integral_saturation_limit)),
        reset_integral_(::flatbuffers::EndianScalar(static_cast<uint8_t>(_reset_integral))),
        padding0__(0),
        padding1__(0) {
    (void)padding0__;
    (void)padding1__;
  }
  float kp() const {
    return ::flatbuffers::EndianScalar(kp_);
  }
  float ki() const {
    return ::flatbuffers::EndianScalar(ki_);
  }
  float kd() const {
    return ::flatbuffers::EndianScalar(kd_);
  }
  float integral_zero_threshold() const {
    return ::flatbuffers::EndianScalar(integral_zero_threshold_);
  }
  float integral_saturation_limit() const {
    return ::flatbuffers::EndianScalar(integral_saturation_limit_);
  }
  bool reset_integral() const {
    return ::flatbuffers::EndianScalar(reset_integral_) != 0;
  }
};
FLATBUFFERS_STRUCT_END(YawPID, 24);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) YawPIDState FLATBUFFERS_FINAL_CLASS {
 private:
  float error_;
  float integral_;
  float derivative_;
  float output_;
  float saturated_;

 public:
  YawPIDState()
      : error_(0),
        integral_(0),
        derivative_(0),
        output_(0),
        saturated_(0) {
  }
  YawPIDState(float _error, float _integral, float _derivative, float _output, float _saturated)
      : error_(::flatbuffers::EndianScalar(_error)),
        integral_(::flatbuffers::EndianScalar(_integral)),
        derivative_(::flatbuffers::EndianScalar(_derivative)),
        output_(::flatbuffers::EndianScalar(_output)),
        saturated_(::flatbuffers::EndianScalar(_saturated)) {
  }
  float error() const {
    return ::flatbuffers::EndianScalar(error_);
  }
  float integral() const {
    return ::flatbuffers::EndianScalar(integral_);
  }
  float derivative() const {
    return ::flatbuffers::EndianScalar(derivative_);
  }
  float output() const {
    return ::flatbuffers::EndianScalar(output_);
  }
  float saturated() const {
    return ::flatbuffers::EndianScalar(saturated_);
  }
};
FLATBUFFERS_STRUCT_END(YawPIDState, 20);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Drive FLATBUFFERS_FINAL_CLASS {
 private:
  float linear_;
  float angular_;

 public:
  Drive()
      : linear_(0),
        angular_(0) {
  }
  Drive(float _linear, float _angular)
      : linear_(::flatbuffers::EndianScalar(_linear)),
        angular_(::flatbuffers::EndianScalar(_angular)) {
  }
  float linear() const {
    return ::flatbuffers::EndianScalar(linear_);
  }
  float angular() const {
    return ::flatbuffers::EndianScalar(angular_);
  }
};
FLATBUFFERS_STRUCT_END(Drive, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) MotorState FLATBUFFERS_FINAL_CLASS {
 private:
  float angle_;
  float measured_speed_;
  float cmd_speed_;

 public:
  MotorState()
      : angle_(0),
        measured_speed_(0),
        cmd_speed_(0) {
  }
  MotorState(float _angle, float _measured_speed, float _cmd_speed)
      : angle_(::flatbuffers::EndianScalar(_angle)),
        measured_speed_(::flatbuffers::EndianScalar(_measured_speed)),
        cmd_speed_(::flatbuffers::EndianScalar(_cmd_speed)) {
  }
  float angle() const {
    return ::flatbuffers::EndianScalar(angle_);
  }
  float measured_speed() const {
    return ::flatbuffers::EndianScalar(measured_speed_);
  }
  float cmd_speed() const {
    return ::flatbuffers::EndianScalar(cmd_speed_);
  }
};
FLATBUFFERS_STRUCT_END(MotorState, 12);

struct PitchController FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PitchControllerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACTIVE = 4,
    VT_PID = 6
  };
  BalanceBotFlatbuffers::PitchControllerType active() const {
    return static_cast<BalanceBotFlatbuffers::PitchControllerType>(GetField<int8_t>(VT_ACTIVE, 0));
  }
  const BalanceBotFlatbuffers::PitchPID *pid() const {
    return GetStruct<const BalanceBotFlatbuffers::PitchPID *>(VT_PID);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_ACTIVE, 1) &&
           VerifyField<BalanceBotFlatbuffers::PitchPID>(verifier, VT_PID, 4) &&
           verifier.EndTable();
  }
};

struct PitchControllerBuilder {
  typedef PitchController Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_active(BalanceBotFlatbuffers::PitchControllerType active) {
    fbb_.AddElement<int8_t>(PitchController::VT_ACTIVE, static_cast<int8_t>(active), 0);
  }
  void add_pid(const BalanceBotFlatbuffers::PitchPID *pid) {
    fbb_.AddStruct(PitchController::VT_PID, pid);
  }
  explicit PitchControllerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PitchController> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PitchController>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PitchController> CreatePitchController(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    BalanceBotFlatbuffers::PitchControllerType active = BalanceBotFlatbuffers::PitchControllerType_PID,
    const BalanceBotFlatbuffers::PitchPID *pid = nullptr) {
  PitchControllerBuilder builder_(_fbb);
  builder_.add_pid(pid);
  builder_.add_active(active);
  return builder_.Finish();
}

struct YawController FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef YawControllerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACTIVE = 4,
    VT_PID = 6
  };
  BalanceBotFlatbuffers::YawControllerType active() const {
    return static_cast<BalanceBotFlatbuffers::YawControllerType>(GetField<int8_t>(VT_ACTIVE, 0));
  }
  const BalanceBotFlatbuffers::YawPID *pid() const {
    return GetStruct<const BalanceBotFlatbuffers::YawPID *>(VT_PID);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_ACTIVE, 1) &&
           VerifyField<BalanceBotFlatbuffers::YawPID>(verifier, VT_PID, 4) &&
           verifier.EndTable();
  }
};

struct YawControllerBuilder {
  typedef YawController Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_active(BalanceBotFlatbuffers::YawControllerType active) {
    fbb_.AddElement<int8_t>(YawController::VT_ACTIVE, static_cast<int8_t>(active), 0);
  }
  void add_pid(const BalanceBotFlatbuffers::YawPID *pid) {
    fbb_.AddStruct(YawController::VT_PID, pid);
  }
  explicit YawControllerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<YawController> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<YawController>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<YawController> CreateYawController(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    BalanceBotFlatbuffers::YawControllerType active = BalanceBotFlatbuffers::YawControllerType_PID,
    const BalanceBotFlatbuffers::YawPID *pid = nullptr) {
  YawControllerBuilder builder_(_fbb);
  builder_.add_pid(pid);
  builder_.add_active(active);
  return builder_.Finish();
}

struct PhysicalCharacteristics FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PhysicalCharacteristicsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WHEEL_RADIUS = 4,
    VT_WHEEL_BASE = 6,
    VT_GRAVITY_ACCEL = 8,
    VT_TORQUE_LENGTH = 10
  };
  float wheel_radius() const {
    return GetField<float>(VT_WHEEL_RADIUS, 0.0f);
  }
  float wheel_base() const {
    return GetField<float>(VT_WHEEL_BASE, 0.0f);
  }
  float gravity_accel() const {
    return GetField<float>(VT_GRAVITY_ACCEL, 0.0f);
  }
  float torque_length() const {
    return GetField<float>(VT_TORQUE_LENGTH, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_WHEEL_RADIUS, 4) &&
           VerifyField<float>(verifier, VT_WHEEL_BASE, 4) &&
           VerifyField<float>(verifier, VT_GRAVITY_ACCEL, 4) &&
           VerifyField<float>(verifier, VT_TORQUE_LENGTH, 4) &&
           verifier.EndTable();
  }
};

struct PhysicalCharacteristicsBuilder {
  typedef PhysicalCharacteristics Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_wheel_radius(float wheel_radius) {
    fbb_.AddElement<float>(PhysicalCharacteristics::VT_WHEEL_RADIUS, wheel_radius, 0.0f);
  }
  void add_wheel_base(float wheel_base) {
    fbb_.AddElement<float>(PhysicalCharacteristics::VT_WHEEL_BASE, wheel_base, 0.0f);
  }
  void add_gravity_accel(float gravity_accel) {
    fbb_.AddElement<float>(PhysicalCharacteristics::VT_GRAVITY_ACCEL, gravity_accel, 0.0f);
  }
  void add_torque_length(float torque_length) {
    fbb_.AddElement<float>(PhysicalCharacteristics::VT_TORQUE_LENGTH, torque_length, 0.0f);
  }
  explicit PhysicalCharacteristicsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PhysicalCharacteristics> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PhysicalCharacteristics>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PhysicalCharacteristics> CreatePhysicalCharacteristics(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float wheel_radius = 0.0f,
    float wheel_base = 0.0f,
    float gravity_accel = 0.0f,
    float torque_length = 0.0f) {
  PhysicalCharacteristicsBuilder builder_(_fbb);
  builder_.add_torque_length(torque_length);
  builder_.add_gravity_accel(gravity_accel);
  builder_.add_wheel_base(wheel_base);
  builder_.add_wheel_radius(wheel_radius);
  return builder_.Finish();
}

struct MotorConfig FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MotorConfigBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MAX_SPEED = 4,
    VT_STATIC_FRICTION_NEG = 6,
    VT_STATIC_FRICTION_POS = 8,
    VT_STATIC_FRICTION_TIME = 10,
    VT_BRAKE_TIME = 12,
    VT_LUT = 14
  };
  uint8_t max_speed() const {
    return GetField<uint8_t>(VT_MAX_SPEED, 100);
  }
  uint16_t static_friction_neg() const {
    return GetField<uint16_t>(VT_STATIC_FRICTION_NEG, 65535);
  }
  uint16_t static_friction_pos() const {
    return GetField<uint16_t>(VT_STATIC_FRICTION_POS, 65535);
  }
  uint32_t static_friction_time() const {
    return GetField<uint32_t>(VT_STATIC_FRICTION_TIME, 100000);
  }
  uint32_t brake_time() const {
    return GetField<uint32_t>(VT_BRAKE_TIME, 100000);
  }
  const ::flatbuffers::Vector<uint32_t> *lut() const {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_LUT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MAX_SPEED, 1) &&
           VerifyField<uint16_t>(verifier, VT_STATIC_FRICTION_NEG, 2) &&
           VerifyField<uint16_t>(verifier, VT_STATIC_FRICTION_POS, 2) &&
           VerifyField<uint32_t>(verifier, VT_STATIC_FRICTION_TIME, 4) &&
           VerifyField<uint32_t>(verifier, VT_BRAKE_TIME, 4) &&
           VerifyOffset(verifier, VT_LUT) &&
           verifier.VerifyVector(lut()) &&
           verifier.EndTable();
  }
};

struct MotorConfigBuilder {
  typedef MotorConfig Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_max_speed(uint8_t max_speed) {
    fbb_.AddElement<uint8_t>(MotorConfig::VT_MAX_SPEED, max_speed, 100);
  }
  void add_static_friction_neg(uint16_t static_friction_neg) {
    fbb_.AddElement<uint16_t>(MotorConfig::VT_STATIC_FRICTION_NEG, static_friction_neg, 65535);
  }
  void add_static_friction_pos(uint16_t static_friction_pos) {
    fbb_.AddElement<uint16_t>(MotorConfig::VT_STATIC_FRICTION_POS, static_friction_pos, 65535);
  }
  void add_static_friction_time(uint32_t static_friction_time) {
    fbb_.AddElement<uint32_t>(MotorConfig::VT_STATIC_FRICTION_TIME, static_friction_time, 100000);
  }
  void add_brake_time(uint32_t brake_time) {
    fbb_.AddElement<uint32_t>(MotorConfig::VT_BRAKE_TIME, brake_time, 100000);
  }
  void add_lut(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> lut) {
    fbb_.AddOffset(MotorConfig::VT_LUT, lut);
  }
  explicit MotorConfigBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MotorConfig> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MotorConfig>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MotorConfig> CreateMotorConfig(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t max_speed = 100,
    uint16_t static_friction_neg = 65535,
    uint16_t static_friction_pos = 65535,
    uint32_t static_friction_time = 100000,
    uint32_t brake_time = 100000,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> lut = 0) {
  MotorConfigBuilder builder_(_fbb);
  builder_.add_lut(lut);
  builder_.add_brake_time(brake_time);
  builder_.add_static_friction_time(static_friction_time);
  builder_.add_static_friction_pos(static_friction_pos);
  builder_.add_static_friction_neg(static_friction_neg);
  builder_.add_max_speed(max_speed);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<MotorConfig> CreateMotorConfigDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t max_speed = 100,
    uint16_t static_friction_neg = 65535,
    uint16_t static_friction_pos = 65535,
    uint32_t static_friction_time = 100000,
    uint32_t brake_time = 100000,
    const std::vector<uint32_t> *lut = nullptr) {
  auto lut__ = lut ? _fbb.CreateVector<uint32_t>(*lut) : 0;
  return BalanceBotFlatbuffers::CreateMotorConfig(
      _fbb,
      max_speed,
      static_friction_neg,
      static_friction_pos,
      static_friction_time,
      brake_time,
      lut__);
}

struct Web2Bot FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Web2BotBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_WRITE_ENABLE_BALANCING = 6,
    VT_WRITE_PITCH = 8,
    VT_WRITE_YAW = 10,
    VT_WRITE_PHYSICAL = 12,
    VT_WRITE_MOTOR_L = 14,
    VT_WRITE_MOTOR_R = 16,
    VT_SAVE_ENABLE_BALANCING = 18,
    VT_SAVE_PITCH = 20,
    VT_SAVE_YAW = 22,
    VT_SAVE_PHYSICAL = 24,
    VT_SAVE_MOTOR_L = 26,
    VT_SAVE_MOTOR_R = 28,
    VT_READ_CURR_ENABLE_BALANCING = 30,
    VT_READ_CURR_PITCH = 32,
    VT_READ_CURR_YAW = 34,
    VT_READ_CURR_PHYSICAL = 36,
    VT_READ_CURR_MOTOR_L = 38,
    VT_READ_CURR_MOTOR_R = 40,
    VT_READ_SAVED_ENABLE_BALANCING = 42,
    VT_READ_SAVED_PITCH = 44,
    VT_READ_SAVED_YAW = 46,
    VT_READ_SAVED_PHYSICAL = 48,
    VT_READ_SAVED_MOTOR_L = 50,
    VT_READ_SAVED_MOTOR_R = 52,
    VT_LOAD_ENABLE_BALANCING = 54,
    VT_LOAD_PITCH = 56,
    VT_LOAD_YAW = 58,
    VT_LOAD_PHYSICAL = 60,
    VT_LOAD_MOTOR_L = 62,
    VT_LOAD_MOTOR_R = 64,
    VT_DRIVE = 66
  };
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  int8_t write_enable_balancing() const {
    return GetField<int8_t>(VT_WRITE_ENABLE_BALANCING, 0);
  }
  const BalanceBotFlatbuffers::PitchController *write_pitch() const {
    return GetPointer<const BalanceBotFlatbuffers::PitchController *>(VT_WRITE_PITCH);
  }
  const BalanceBotFlatbuffers::YawController *write_yaw() const {
    return GetPointer<const BalanceBotFlatbuffers::YawController *>(VT_WRITE_YAW);
  }
  const BalanceBotFlatbuffers::PhysicalCharacteristics *write_physical() const {
    return GetPointer<const BalanceBotFlatbuffers::PhysicalCharacteristics *>(VT_WRITE_PHYSICAL);
  }
  const BalanceBotFlatbuffers::MotorConfig *write_motor_l() const {
    return GetPointer<const BalanceBotFlatbuffers::MotorConfig *>(VT_WRITE_MOTOR_L);
  }
  const BalanceBotFlatbuffers::MotorConfig *write_motor_r() const {
    return GetPointer<const BalanceBotFlatbuffers::MotorConfig *>(VT_WRITE_MOTOR_R);
  }
  bool save_enable_balancing() const {
    return GetField<uint8_t>(VT_SAVE_ENABLE_BALANCING, 0) != 0;
  }
  bool save_pitch() const {
    return GetField<uint8_t>(VT_SAVE_PITCH, 0) != 0;
  }
  bool save_yaw() const {
    return GetField<uint8_t>(VT_SAVE_YAW, 0) != 0;
  }
  bool save_physical() const {
    return GetField<uint8_t>(VT_SAVE_PHYSICAL, 0) != 0;
  }
  bool save_motor_l() const {
    return GetField<uint8_t>(VT_SAVE_MOTOR_L, 0) != 0;
  }
  bool save_motor_r() const {
    return GetField<uint8_t>(VT_SAVE_MOTOR_R, 0) != 0;
  }
  bool read_curr_enable_balancing() const {
    return GetField<uint8_t>(VT_READ_CURR_ENABLE_BALANCING, 0) != 0;
  }
  bool read_curr_pitch() const {
    return GetField<uint8_t>(VT_READ_CURR_PITCH, 0) != 0;
  }
  bool read_curr_yaw() const {
    return GetField<uint8_t>(VT_READ_CURR_YAW, 0) != 0;
  }
  bool read_curr_physical() const {
    return GetField<uint8_t>(VT_READ_CURR_PHYSICAL, 0) != 0;
  }
  bool read_curr_motor_l() const {
    return GetField<uint8_t>(VT_READ_CURR_MOTOR_L, 0) != 0;
  }
  bool read_curr_motor_r() const {
    return GetField<uint8_t>(VT_READ_CURR_MOTOR_R, 0) != 0;
  }
  bool read_saved_enable_balancing() const {
    return GetField<uint8_t>(VT_READ_SAVED_ENABLE_BALANCING, 0) != 0;
  }
  bool read_saved_pitch() const {
    return GetField<uint8_t>(VT_READ_SAVED_PITCH, 0) != 0;
  }
  bool read_saved_yaw() const {
    return GetField<uint8_t>(VT_READ_SAVED_YAW, 0) != 0;
  }
  bool read_saved_physical() const {
    return GetField<uint8_t>(VT_READ_SAVED_PHYSICAL, 0) != 0;
  }
  bool read_saved_motor_l() const {
    return GetField<uint8_t>(VT_READ_SAVED_MOTOR_L, 0) != 0;
  }
  bool read_saved_motor_r() const {
    return GetField<uint8_t>(VT_READ_SAVED_MOTOR_R, 0) != 0;
  }
  bool load_enable_balancing() const {
    return GetField<uint8_t>(VT_LOAD_ENABLE_BALANCING, 0) != 0;
  }
  bool load_pitch() const {
    return GetField<uint8_t>(VT_LOAD_PITCH, 0) != 0;
  }
  bool load_yaw() const {
    return GetField<uint8_t>(VT_LOAD_YAW, 0) != 0;
  }
  bool load_physical() const {
    return GetField<uint8_t>(VT_LOAD_PHYSICAL, 0) != 0;
  }
  bool load_motor_l() const {
    return GetField<uint8_t>(VT_LOAD_MOTOR_L, 0) != 0;
  }
  bool load_motor_r() const {
    return GetField<uint8_t>(VT_LOAD_MOTOR_R, 0) != 0;
  }
  const BalanceBotFlatbuffers::Drive *drive() const {
    return GetStruct<const BalanceBotFlatbuffers::Drive *>(VT_DRIVE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID, 4) &&
           VerifyField<int8_t>(verifier, VT_WRITE_ENABLE_BALANCING, 1) &&
           VerifyOffset(verifier, VT_WRITE_PITCH) &&
           verifier.VerifyTable(write_pitch()) &&
           VerifyOffset(verifier, VT_WRITE_YAW) &&
           verifier.VerifyTable(write_yaw()) &&
           VerifyOffset(verifier, VT_WRITE_PHYSICAL) &&
           verifier.VerifyTable(write_physical()) &&
           VerifyOffset(verifier, VT_WRITE_MOTOR_L) &&
           verifier.VerifyTable(write_motor_l()) &&
           VerifyOffset(verifier, VT_WRITE_MOTOR_R) &&
           verifier.VerifyTable(write_motor_r()) &&
           VerifyField<uint8_t>(verifier, VT_SAVE_ENABLE_BALANCING, 1) &&
           VerifyField<uint8_t>(verifier, VT_SAVE_PITCH, 1) &&
           VerifyField<uint8_t>(verifier, VT_SAVE_YAW, 1) &&
           VerifyField<uint8_t>(verifier, VT_SAVE_PHYSICAL, 1) &&
           VerifyField<uint8_t>(verifier, VT_SAVE_MOTOR_L, 1) &&
           VerifyField<uint8_t>(verifier, VT_SAVE_MOTOR_R, 1) &&
           VerifyField<uint8_t>(verifier, VT_READ_CURR_ENABLE_BALANCING, 1) &&
           VerifyField<uint8_t>(verifier, VT_READ_CURR_PITCH, 1) &&
           VerifyField<uint8_t>(verifier, VT_READ_CURR_YAW, 1) &&
           VerifyField<uint8_t>(verifier, VT_READ_CURR_PHYSICAL, 1) &&
           VerifyField<uint8_t>(verifier, VT_READ_CURR_MOTOR_L, 1) &&
           VerifyField<uint8_t>(verifier, VT_READ_CURR_MOTOR_R, 1) &&
           VerifyField<uint8_t>(verifier, VT_READ_SAVED_ENABLE_BALANCING, 1) &&
           VerifyField<uint8_t>(verifier, VT_READ_SAVED_PITCH, 1) &&
           VerifyField<uint8_t>(verifier, VT_READ_SAVED_YAW, 1) &&
           VerifyField<uint8_t>(verifier, VT_READ_SAVED_PHYSICAL, 1) &&
           VerifyField<uint8_t>(verifier, VT_READ_SAVED_MOTOR_L, 1) &&
           VerifyField<uint8_t>(verifier, VT_READ_SAVED_MOTOR_R, 1) &&
           VerifyField<uint8_t>(verifier, VT_LOAD_ENABLE_BALANCING, 1) &&
           VerifyField<uint8_t>(verifier, VT_LOAD_PITCH, 1) &&
           VerifyField<uint8_t>(verifier, VT_LOAD_YAW, 1) &&
           VerifyField<uint8_t>(verifier, VT_LOAD_PHYSICAL, 1) &&
           VerifyField<uint8_t>(verifier, VT_LOAD_MOTOR_L, 1) &&
           VerifyField<uint8_t>(verifier, VT_LOAD_MOTOR_R, 1) &&
           VerifyField<BalanceBotFlatbuffers::Drive>(verifier, VT_DRIVE, 4) &&
           verifier.EndTable();
  }
};

struct Web2BotBuilder {
  typedef Web2Bot Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(Web2Bot::VT_ID, id, 0);
  }
  void add_write_enable_balancing(int8_t write_enable_balancing) {
    fbb_.AddElement<int8_t>(Web2Bot::VT_WRITE_ENABLE_BALANCING, write_enable_balancing, 0);
  }
  void add_write_pitch(::flatbuffers::Offset<BalanceBotFlatbuffers::PitchController> write_pitch) {
    fbb_.AddOffset(Web2Bot::VT_WRITE_PITCH, write_pitch);
  }
  void add_write_yaw(::flatbuffers::Offset<BalanceBotFlatbuffers::YawController> write_yaw) {
    fbb_.AddOffset(Web2Bot::VT_WRITE_YAW, write_yaw);
  }
  void add_write_physical(::flatbuffers::Offset<BalanceBotFlatbuffers::PhysicalCharacteristics> write_physical) {
    fbb_.AddOffset(Web2Bot::VT_WRITE_PHYSICAL, write_physical);
  }
  void add_write_motor_l(::flatbuffers::Offset<BalanceBotFlatbuffers::MotorConfig> write_motor_l) {
    fbb_.AddOffset(Web2Bot::VT_WRITE_MOTOR_L, write_motor_l);
  }
  void add_write_motor_r(::flatbuffers::Offset<BalanceBotFlatbuffers::MotorConfig> write_motor_r) {
    fbb_.AddOffset(Web2Bot::VT_WRITE_MOTOR_R, write_motor_r);
  }
  void add_save_enable_balancing(bool save_enable_balancing) {
    fbb_.AddElement<uint8_t>(Web2Bot::VT_SAVE_ENABLE_BALANCING, static_cast<uint8_t>(save_enable_balancing), 0);
  }
  void add_save_pitch(bool save_pitch) {
    fbb_.AddElement<uint8_t>(Web2Bot::VT_SAVE_PITCH, static_cast<uint8_t>(save_pitch), 0);
  }
  void add_save_yaw(bool save_yaw) {
    fbb_.AddElement<uint8_t>(Web2Bot::VT_SAVE_YAW, static_cast<uint8_t>(save_yaw), 0);
  }
  void add_save_physical(bool save_physical) {
    fbb_.AddElement<uint8_t>(Web2Bot::VT_SAVE_PHYSICAL, static_cast<uint8_t>(save_physical), 0);
  }
  void add_save_motor_l(bool save_motor_l) {
    fbb_.AddElement<uint8_t>(Web2Bot::VT_SAVE_MOTOR_L, static_cast<uint8_t>(save_motor_l), 0);
  }
  void add_save_motor_r(bool save_motor_r) {
    fbb_.AddElement<uint8_t>(Web2Bot::VT_SAVE_MOTOR_R, static_cast<uint8_t>(save_motor_r), 0);
  }
  void add_read_curr_enable_balancing(bool read_curr_enable_balancing) {
    fbb_.AddElement<uint8_t>(Web2Bot::VT_READ_CURR_ENABLE_BALANCING, static_cast<uint8_t>(read_curr_enable_balancing), 0);
  }
  void add_read_curr_pitch(bool read_curr_pitch) {
    fbb_.AddElement<uint8_t>(Web2Bot::VT_READ_CURR_PITCH, static_cast<uint8_t>(read_curr_pitch), 0);
  }
  void add_read_curr_yaw(bool read_curr_yaw) {
    fbb_.AddElement<uint8_t>(Web2Bot::VT_READ_CURR_YAW, static_cast<uint8_t>(read_curr_yaw), 0);
  }
  void add_read_curr_physical(bool read_curr_physical) {
    fbb_.AddElement<uint8_t>(Web2Bot::VT_READ_CURR_PHYSICAL, static_cast<uint8_t>(read_curr_physical), 0);
  }
  void add_read_curr_motor_l(bool read_curr_motor_l) {
    fbb_.AddElement<uint8_t>(Web2Bot::VT_READ_CURR_MOTOR_L, static_cast<uint8_t>(read_curr_motor_l), 0);
  }
  void add_read_curr_motor_r(bool read_curr_motor_r) {
    fbb_.AddElement<uint8_t>(Web2Bot::VT_READ_CURR_MOTOR_R, static_cast<uint8_t>(read_curr_motor_r), 0);
  }
  void add_read_saved_enable_balancing(bool read_saved_enable_balancing) {
    fbb_.AddElement<uint8_t>(Web2Bot::VT_READ_SAVED_ENABLE_BALANCING, static_cast<uint8_t>(read_saved_enable_balancing), 0);
  }
  void add_read_saved_pitch(bool read_saved_pitch) {
    fbb_.AddElement<uint8_t>(Web2Bot::VT_READ_SAVED_PITCH, static_cast<uint8_t>(read_saved_pitch), 0);
  }
  void add_read_saved_yaw(bool read_saved_yaw) {
    fbb_.AddElement<uint8_t>(Web2Bot::VT_READ_SAVED_YAW, static_cast<uint8_t>(read_saved_yaw), 0);
  }
  void add_read_saved_physical(bool read_saved_physical) {
    fbb_.AddElement<uint8_t>(Web2Bot::VT_READ_SAVED_PHYSICAL, static_cast<uint8_t>(read_saved_physical), 0);
  }
  void add_read_saved_motor_l(bool read_saved_motor_l) {
    fbb_.AddElement<uint8_t>(Web2Bot::VT_READ_SAVED_MOTOR_L, static_cast<uint8_t>(read_saved_motor_l), 0);
  }
  void add_read_saved_motor_r(bool read_saved_motor_r) {
    fbb_.AddElement<uint8_t>(Web2Bot::VT_READ_SAVED_MOTOR_R, static_cast<uint8_t>(read_saved_motor_r), 0);
  }
  void add_load_enable_balancing(bool load_enable_balancing) {
    fbb_.AddElement<uint8_t>(Web2Bot::VT_LOAD_ENABLE_BALANCING, static_cast<uint8_t>(load_enable_balancing), 0);
  }
  void add_load_pitch(bool load_pitch) {
    fbb_.AddElement<uint8_t>(Web2Bot::VT_LOAD_PITCH, static_cast<uint8_t>(load_pitch), 0);
  }
  void add_load_yaw(bool load_yaw) {
    fbb_.AddElement<uint8_t>(Web2Bot::VT_LOAD_YAW, static_cast<uint8_t>(load_yaw), 0);
  }
  void add_load_physical(bool load_physical) {
    fbb_.AddElement<uint8_t>(Web2Bot::VT_LOAD_PHYSICAL, static_cast<uint8_t>(load_physical), 0);
  }
  void add_load_motor_l(bool load_motor_l) {
    fbb_.AddElement<uint8_t>(Web2Bot::VT_LOAD_MOTOR_L, static_cast<uint8_t>(load_motor_l), 0);
  }
  void add_load_motor_r(bool load_motor_r) {
    fbb_.AddElement<uint8_t>(Web2Bot::VT_LOAD_MOTOR_R, static_cast<uint8_t>(load_motor_r), 0);
  }
  void add_drive(const BalanceBotFlatbuffers::Drive *drive) {
    fbb_.AddStruct(Web2Bot::VT_DRIVE, drive);
  }
  explicit Web2BotBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Web2Bot> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Web2Bot>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Web2Bot> CreateWeb2Bot(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    int8_t write_enable_balancing = 0,
    ::flatbuffers::Offset<BalanceBotFlatbuffers::PitchController> write_pitch = 0,
    ::flatbuffers::Offset<BalanceBotFlatbuffers::YawController> write_yaw = 0,
    ::flatbuffers::Offset<BalanceBotFlatbuffers::PhysicalCharacteristics> write_physical = 0,
    ::flatbuffers::Offset<BalanceBotFlatbuffers::MotorConfig> write_motor_l = 0,
    ::flatbuffers::Offset<BalanceBotFlatbuffers::MotorConfig> write_motor_r = 0,
    bool save_enable_balancing = false,
    bool save_pitch = false,
    bool save_yaw = false,
    bool save_physical = false,
    bool save_motor_l = false,
    bool save_motor_r = false,
    bool read_curr_enable_balancing = false,
    bool read_curr_pitch = false,
    bool read_curr_yaw = false,
    bool read_curr_physical = false,
    bool read_curr_motor_l = false,
    bool read_curr_motor_r = false,
    bool read_saved_enable_balancing = false,
    bool read_saved_pitch = false,
    bool read_saved_yaw = false,
    bool read_saved_physical = false,
    bool read_saved_motor_l = false,
    bool read_saved_motor_r = false,
    bool load_enable_balancing = false,
    bool load_pitch = false,
    bool load_yaw = false,
    bool load_physical = false,
    bool load_motor_l = false,
    bool load_motor_r = false,
    const BalanceBotFlatbuffers::Drive *drive = nullptr) {
  Web2BotBuilder builder_(_fbb);
  builder_.add_drive(drive);
  builder_.add_write_motor_r(write_motor_r);
  builder_.add_write_motor_l(write_motor_l);
  builder_.add_write_physical(write_physical);
  builder_.add_write_yaw(write_yaw);
  builder_.add_write_pitch(write_pitch);
  builder_.add_id(id);
  builder_.add_load_motor_r(load_motor_r);
  builder_.add_load_motor_l(load_motor_l);
  builder_.add_load_physical(load_physical);
  builder_.add_load_yaw(load_yaw);
  builder_.add_load_pitch(load_pitch);
  builder_.add_load_enable_balancing(load_enable_balancing);
  builder_.add_read_saved_motor_r(read_saved_motor_r);
  builder_.add_read_saved_motor_l(read_saved_motor_l);
  builder_.add_read_saved_physical(read_saved_physical);
  builder_.add_read_saved_yaw(read_saved_yaw);
  builder_.add_read_saved_pitch(read_saved_pitch);
  builder_.add_read_saved_enable_balancing(read_saved_enable_balancing);
  builder_.add_read_curr_motor_r(read_curr_motor_r);
  builder_.add_read_curr_motor_l(read_curr_motor_l);
  builder_.add_read_curr_physical(read_curr_physical);
  builder_.add_read_curr_yaw(read_curr_yaw);
  builder_.add_read_curr_pitch(read_curr_pitch);
  builder_.add_read_curr_enable_balancing(read_curr_enable_balancing);
  builder_.add_save_motor_r(save_motor_r);
  builder_.add_save_motor_l(save_motor_l);
  builder_.add_save_physical(save_physical);
  builder_.add_save_yaw(save_yaw);
  builder_.add_save_pitch(save_pitch);
  builder_.add_save_enable_balancing(save_enable_balancing);
  builder_.add_write_enable_balancing(write_enable_balancing);
  return builder_.Finish();
}

struct RobotState FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RobotStateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIMESTAMP = 4,
    VT_PITCH = 6,
    VT_YAW = 8,
    VT_LEFT_MOTOR = 10,
    VT_RIGHT_MOTOR = 12,
    VT_PITCH_STATE_TYPE = 14,
    VT_PITCH_STATE = 16,
    VT_YAW_STATE_TYPE = 18,
    VT_YAW_STATE = 20,
    VT_DIST_TRAVELLED = 22
  };
  int64_t timestamp() const {
    return GetField<int64_t>(VT_TIMESTAMP, 0);
  }
  float pitch() const {
    return GetField<float>(VT_PITCH, 0.0f);
  }
  float yaw() const {
    return GetField<float>(VT_YAW, 0.0f);
  }
  const BalanceBotFlatbuffers::MotorState *left_motor() const {
    return GetStruct<const BalanceBotFlatbuffers::MotorState *>(VT_LEFT_MOTOR);
  }
  const BalanceBotFlatbuffers::MotorState *right_motor() const {
    return GetStruct<const BalanceBotFlatbuffers::MotorState *>(VT_RIGHT_MOTOR);
  }
  BalanceBotFlatbuffers::PitchControllerState pitch_state_type() const {
    return static_cast<BalanceBotFlatbuffers::PitchControllerState>(GetField<uint8_t>(VT_PITCH_STATE_TYPE, 0));
  }
  const void *pitch_state() const {
    return GetPointer<const void *>(VT_PITCH_STATE);
  }
  template<typename T> const T *pitch_state_as() const;
  const BalanceBotFlatbuffers::PitchPIDState *pitch_state_as_PID() const {
    return pitch_state_type() == BalanceBotFlatbuffers::PitchControllerState_PID ? static_cast<const BalanceBotFlatbuffers::PitchPIDState *>(pitch_state()) : nullptr;
  }
  BalanceBotFlatbuffers::YawControllerState yaw_state_type() const {
    return static_cast<BalanceBotFlatbuffers::YawControllerState>(GetField<uint8_t>(VT_YAW_STATE_TYPE, 0));
  }
  const void *yaw_state() const {
    return GetPointer<const void *>(VT_YAW_STATE);
  }
  template<typename T> const T *yaw_state_as() const;
  const BalanceBotFlatbuffers::YawPIDState *yaw_state_as_PID() const {
    return yaw_state_type() == BalanceBotFlatbuffers::YawControllerState_PID ? static_cast<const BalanceBotFlatbuffers::YawPIDState *>(yaw_state()) : nullptr;
  }
  float dist_travelled() const {
    return GetField<float>(VT_DIST_TRAVELLED, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_TIMESTAMP, 8) &&
           VerifyField<float>(verifier, VT_PITCH, 4) &&
           VerifyField<float>(verifier, VT_YAW, 4) &&
           VerifyField<BalanceBotFlatbuffers::MotorState>(verifier, VT_LEFT_MOTOR, 4) &&
           VerifyField<BalanceBotFlatbuffers::MotorState>(verifier, VT_RIGHT_MOTOR, 4) &&
           VerifyField<uint8_t>(verifier, VT_PITCH_STATE_TYPE, 1) &&
           VerifyOffset(verifier, VT_PITCH_STATE) &&
           VerifyPitchControllerState(verifier, pitch_state(), pitch_state_type()) &&
           VerifyField<uint8_t>(verifier, VT_YAW_STATE_TYPE, 1) &&
           VerifyOffset(verifier, VT_YAW_STATE) &&
           VerifyYawControllerState(verifier, yaw_state(), yaw_state_type()) &&
           VerifyField<float>(verifier, VT_DIST_TRAVELLED, 4) &&
           verifier.EndTable();
  }
};

template<> inline const BalanceBotFlatbuffers::PitchPIDState *RobotState::pitch_state_as<BalanceBotFlatbuffers::PitchPIDState>() const {
  return pitch_state_as_PID();
}

template<> inline const BalanceBotFlatbuffers::YawPIDState *RobotState::yaw_state_as<BalanceBotFlatbuffers::YawPIDState>() const {
  return yaw_state_as_PID();
}

struct RobotStateBuilder {
  typedef RobotState Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_timestamp(int64_t timestamp) {
    fbb_.AddElement<int64_t>(RobotState::VT_TIMESTAMP, timestamp, 0);
  }
  void add_pitch(float pitch) {
    fbb_.AddElement<float>(RobotState::VT_PITCH, pitch, 0.0f);
  }
  void add_yaw(float yaw) {
    fbb_.AddElement<float>(RobotState::VT_YAW, yaw, 0.0f);
  }
  void add_left_motor(const BalanceBotFlatbuffers::MotorState *left_motor) {
    fbb_.AddStruct(RobotState::VT_LEFT_MOTOR, left_motor);
  }
  void add_right_motor(const BalanceBotFlatbuffers::MotorState *right_motor) {
    fbb_.AddStruct(RobotState::VT_RIGHT_MOTOR, right_motor);
  }
  void add_pitch_state_type(BalanceBotFlatbuffers::PitchControllerState pitch_state_type) {
    fbb_.AddElement<uint8_t>(RobotState::VT_PITCH_STATE_TYPE, static_cast<uint8_t>(pitch_state_type), 0);
  }
  void add_pitch_state(::flatbuffers::Offset<void> pitch_state) {
    fbb_.AddOffset(RobotState::VT_PITCH_STATE, pitch_state);
  }
  void add_yaw_state_type(BalanceBotFlatbuffers::YawControllerState yaw_state_type) {
    fbb_.AddElement<uint8_t>(RobotState::VT_YAW_STATE_TYPE, static_cast<uint8_t>(yaw_state_type), 0);
  }
  void add_yaw_state(::flatbuffers::Offset<void> yaw_state) {
    fbb_.AddOffset(RobotState::VT_YAW_STATE, yaw_state);
  }
  void add_dist_travelled(float dist_travelled) {
    fbb_.AddElement<float>(RobotState::VT_DIST_TRAVELLED, dist_travelled, 0.0f);
  }
  explicit RobotStateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RobotState> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RobotState>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RobotState> CreateRobotState(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t timestamp = 0,
    float pitch = 0.0f,
    float yaw = 0.0f,
    const BalanceBotFlatbuffers::MotorState *left_motor = nullptr,
    const BalanceBotFlatbuffers::MotorState *right_motor = nullptr,
    BalanceBotFlatbuffers::PitchControllerState pitch_state_type = BalanceBotFlatbuffers::PitchControllerState_NONE,
    ::flatbuffers::Offset<void> pitch_state = 0,
    BalanceBotFlatbuffers::YawControllerState yaw_state_type = BalanceBotFlatbuffers::YawControllerState_NONE,
    ::flatbuffers::Offset<void> yaw_state = 0,
    float dist_travelled = 0.0f) {
  RobotStateBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_dist_travelled(dist_travelled);
  builder_.add_yaw_state(yaw_state);
  builder_.add_pitch_state(pitch_state);
  builder_.add_right_motor(right_motor);
  builder_.add_left_motor(left_motor);
  builder_.add_yaw(yaw);
  builder_.add_pitch(pitch);
  builder_.add_yaw_state_type(yaw_state_type);
  builder_.add_pitch_state_type(pitch_state_type);
  return builder_.Finish();
}

struct Bot2Web FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Bot2WebBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACK = 4,
    VT_CURR_ENABLE_BALANCING = 6,
    VT_CURR_PITCH = 8,
    VT_CURR_YAW = 10,
    VT_CURR_PHYSICAL = 12,
    VT_CURR_MOTOR_L = 14,
    VT_CURR_MOTOR_R = 16,
    VT_SAVED_ENABLE_BALANCING = 18,
    VT_SAVED_PITCH = 20,
    VT_SAVED_YAW = 22,
    VT_SAVED_PHYSICAL = 24,
    VT_SAVED_MOTOR_L = 26,
    VT_SAVED_MOTOR_R = 28,
    VT_ROBOT_STATE = 30,
    VT_LOG = 32
  };
  uint32_t ack() const {
    return GetField<uint32_t>(VT_ACK, 0);
  }
  int8_t curr_enable_balancing() const {
    return GetField<int8_t>(VT_CURR_ENABLE_BALANCING, 0);
  }
  const BalanceBotFlatbuffers::PitchController *curr_pitch() const {
    return GetPointer<const BalanceBotFlatbuffers::PitchController *>(VT_CURR_PITCH);
  }
  const BalanceBotFlatbuffers::YawController *curr_yaw() const {
    return GetPointer<const BalanceBotFlatbuffers::YawController *>(VT_CURR_YAW);
  }
  const BalanceBotFlatbuffers::PhysicalCharacteristics *curr_physical() const {
    return GetPointer<const BalanceBotFlatbuffers::PhysicalCharacteristics *>(VT_CURR_PHYSICAL);
  }
  const BalanceBotFlatbuffers::MotorConfig *curr_motor_l() const {
    return GetPointer<const BalanceBotFlatbuffers::MotorConfig *>(VT_CURR_MOTOR_L);
  }
  const BalanceBotFlatbuffers::MotorConfig *curr_motor_r() const {
    return GetPointer<const BalanceBotFlatbuffers::MotorConfig *>(VT_CURR_MOTOR_R);
  }
  int8_t saved_enable_balancing() const {
    return GetField<int8_t>(VT_SAVED_ENABLE_BALANCING, 0);
  }
  const BalanceBotFlatbuffers::PitchController *saved_pitch() const {
    return GetPointer<const BalanceBotFlatbuffers::PitchController *>(VT_SAVED_PITCH);
  }
  const BalanceBotFlatbuffers::YawController *saved_yaw() const {
    return GetPointer<const BalanceBotFlatbuffers::YawController *>(VT_SAVED_YAW);
  }
  const BalanceBotFlatbuffers::PhysicalCharacteristics *saved_physical() const {
    return GetPointer<const BalanceBotFlatbuffers::PhysicalCharacteristics *>(VT_SAVED_PHYSICAL);
  }
  const BalanceBotFlatbuffers::MotorConfig *saved_motor_l() const {
    return GetPointer<const BalanceBotFlatbuffers::MotorConfig *>(VT_SAVED_MOTOR_L);
  }
  const BalanceBotFlatbuffers::MotorConfig *saved_motor_r() const {
    return GetPointer<const BalanceBotFlatbuffers::MotorConfig *>(VT_SAVED_MOTOR_R);
  }
  const BalanceBotFlatbuffers::RobotState *robot_state() const {
    return GetPointer<const BalanceBotFlatbuffers::RobotState *>(VT_ROBOT_STATE);
  }
  const ::flatbuffers::String *log() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LOG);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ACK, 4) &&
           VerifyField<int8_t>(verifier, VT_CURR_ENABLE_BALANCING, 1) &&
           VerifyOffset(verifier, VT_CURR_PITCH) &&
           verifier.VerifyTable(curr_pitch()) &&
           VerifyOffset(verifier, VT_CURR_YAW) &&
           verifier.VerifyTable(curr_yaw()) &&
           VerifyOffset(verifier, VT_CURR_PHYSICAL) &&
           verifier.VerifyTable(curr_physical()) &&
           VerifyOffset(verifier, VT_CURR_MOTOR_L) &&
           verifier.VerifyTable(curr_motor_l()) &&
           VerifyOffset(verifier, VT_CURR_MOTOR_R) &&
           verifier.VerifyTable(curr_motor_r()) &&
           VerifyField<int8_t>(verifier, VT_SAVED_ENABLE_BALANCING, 1) &&
           VerifyOffset(verifier, VT_SAVED_PITCH) &&
           verifier.VerifyTable(saved_pitch()) &&
           VerifyOffset(verifier, VT_SAVED_YAW) &&
           verifier.VerifyTable(saved_yaw()) &&
           VerifyOffset(verifier, VT_SAVED_PHYSICAL) &&
           verifier.VerifyTable(saved_physical()) &&
           VerifyOffset(verifier, VT_SAVED_MOTOR_L) &&
           verifier.VerifyTable(saved_motor_l()) &&
           VerifyOffset(verifier, VT_SAVED_MOTOR_R) &&
           verifier.VerifyTable(saved_motor_r()) &&
           VerifyOffset(verifier, VT_ROBOT_STATE) &&
           verifier.VerifyTable(robot_state()) &&
           VerifyOffset(verifier, VT_LOG) &&
           verifier.VerifyString(log()) &&
           verifier.EndTable();
  }
};

struct Bot2WebBuilder {
  typedef Bot2Web Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ack(uint32_t ack) {
    fbb_.AddElement<uint32_t>(Bot2Web::VT_ACK, ack, 0);
  }
  void add_curr_enable_balancing(int8_t curr_enable_balancing) {
    fbb_.AddElement<int8_t>(Bot2Web::VT_CURR_ENABLE_BALANCING, curr_enable_balancing, 0);
  }
  void add_curr_pitch(::flatbuffers::Offset<BalanceBotFlatbuffers::PitchController> curr_pitch) {
    fbb_.AddOffset(Bot2Web::VT_CURR_PITCH, curr_pitch);
  }
  void add_curr_yaw(::flatbuffers::Offset<BalanceBotFlatbuffers::YawController> curr_yaw) {
    fbb_.AddOffset(Bot2Web::VT_CURR_YAW, curr_yaw);
  }
  void add_curr_physical(::flatbuffers::Offset<BalanceBotFlatbuffers::PhysicalCharacteristics> curr_physical) {
    fbb_.AddOffset(Bot2Web::VT_CURR_PHYSICAL, curr_physical);
  }
  void add_curr_motor_l(::flatbuffers::Offset<BalanceBotFlatbuffers::MotorConfig> curr_motor_l) {
    fbb_.AddOffset(Bot2Web::VT_CURR_MOTOR_L, curr_motor_l);
  }
  void add_curr_motor_r(::flatbuffers::Offset<BalanceBotFlatbuffers::MotorConfig> curr_motor_r) {
    fbb_.AddOffset(Bot2Web::VT_CURR_MOTOR_R, curr_motor_r);
  }
  void add_saved_enable_balancing(int8_t saved_enable_balancing) {
    fbb_.AddElement<int8_t>(Bot2Web::VT_SAVED_ENABLE_BALANCING, saved_enable_balancing, 0);
  }
  void add_saved_pitch(::flatbuffers::Offset<BalanceBotFlatbuffers::PitchController> saved_pitch) {
    fbb_.AddOffset(Bot2Web::VT_SAVED_PITCH, saved_pitch);
  }
  void add_saved_yaw(::flatbuffers::Offset<BalanceBotFlatbuffers::YawController> saved_yaw) {
    fbb_.AddOffset(Bot2Web::VT_SAVED_YAW, saved_yaw);
  }
  void add_saved_physical(::flatbuffers::Offset<BalanceBotFlatbuffers::PhysicalCharacteristics> saved_physical) {
    fbb_.AddOffset(Bot2Web::VT_SAVED_PHYSICAL, saved_physical);
  }
  void add_saved_motor_l(::flatbuffers::Offset<BalanceBotFlatbuffers::MotorConfig> saved_motor_l) {
    fbb_.AddOffset(Bot2Web::VT_SAVED_MOTOR_L, saved_motor_l);
  }
  void add_saved_motor_r(::flatbuffers::Offset<BalanceBotFlatbuffers::MotorConfig> saved_motor_r) {
    fbb_.AddOffset(Bot2Web::VT_SAVED_MOTOR_R, saved_motor_r);
  }
  void add_robot_state(::flatbuffers::Offset<BalanceBotFlatbuffers::RobotState> robot_state) {
    fbb_.AddOffset(Bot2Web::VT_ROBOT_STATE, robot_state);
  }
  void add_log(::flatbuffers::Offset<::flatbuffers::String> log) {
    fbb_.AddOffset(Bot2Web::VT_LOG, log);
  }
  explicit Bot2WebBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Bot2Web> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Bot2Web>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Bot2Web> CreateBot2Web(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t ack = 0,
    int8_t curr_enable_balancing = 0,
    ::flatbuffers::Offset<BalanceBotFlatbuffers::PitchController> curr_pitch = 0,
    ::flatbuffers::Offset<BalanceBotFlatbuffers::YawController> curr_yaw = 0,
    ::flatbuffers::Offset<BalanceBotFlatbuffers::PhysicalCharacteristics> curr_physical = 0,
    ::flatbuffers::Offset<BalanceBotFlatbuffers::MotorConfig> curr_motor_l = 0,
    ::flatbuffers::Offset<BalanceBotFlatbuffers::MotorConfig> curr_motor_r = 0,
    int8_t saved_enable_balancing = 0,
    ::flatbuffers::Offset<BalanceBotFlatbuffers::PitchController> saved_pitch = 0,
    ::flatbuffers::Offset<BalanceBotFlatbuffers::YawController> saved_yaw = 0,
    ::flatbuffers::Offset<BalanceBotFlatbuffers::PhysicalCharacteristics> saved_physical = 0,
    ::flatbuffers::Offset<BalanceBotFlatbuffers::MotorConfig> saved_motor_l = 0,
    ::flatbuffers::Offset<BalanceBotFlatbuffers::MotorConfig> saved_motor_r = 0,
    ::flatbuffers::Offset<BalanceBotFlatbuffers::RobotState> robot_state = 0,
    ::flatbuffers::Offset<::flatbuffers::String> log = 0) {
  Bot2WebBuilder builder_(_fbb);
  builder_.add_log(log);
  builder_.add_robot_state(robot_state);
  builder_.add_saved_motor_r(saved_motor_r);
  builder_.add_saved_motor_l(saved_motor_l);
  builder_.add_saved_physical(saved_physical);
  builder_.add_saved_yaw(saved_yaw);
  builder_.add_saved_pitch(saved_pitch);
  builder_.add_curr_motor_r(curr_motor_r);
  builder_.add_curr_motor_l(curr_motor_l);
  builder_.add_curr_physical(curr_physical);
  builder_.add_curr_yaw(curr_yaw);
  builder_.add_curr_pitch(curr_pitch);
  builder_.add_ack(ack);
  builder_.add_saved_enable_balancing(saved_enable_balancing);
  builder_.add_curr_enable_balancing(curr_enable_balancing);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Bot2Web> CreateBot2WebDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t ack = 0,
    int8_t curr_enable_balancing = 0,
    ::flatbuffers::Offset<BalanceBotFlatbuffers::PitchController> curr_pitch = 0,
    ::flatbuffers::Offset<BalanceBotFlatbuffers::YawController> curr_yaw = 0,
    ::flatbuffers::Offset<BalanceBotFlatbuffers::PhysicalCharacteristics> curr_physical = 0,
    ::flatbuffers::Offset<BalanceBotFlatbuffers::MotorConfig> curr_motor_l = 0,
    ::flatbuffers::Offset<BalanceBotFlatbuffers::MotorConfig> curr_motor_r = 0,
    int8_t saved_enable_balancing = 0,
    ::flatbuffers::Offset<BalanceBotFlatbuffers::PitchController> saved_pitch = 0,
    ::flatbuffers::Offset<BalanceBotFlatbuffers::YawController> saved_yaw = 0,
    ::flatbuffers::Offset<BalanceBotFlatbuffers::PhysicalCharacteristics> saved_physical = 0,
    ::flatbuffers::Offset<BalanceBotFlatbuffers::MotorConfig> saved_motor_l = 0,
    ::flatbuffers::Offset<BalanceBotFlatbuffers::MotorConfig> saved_motor_r = 0,
    ::flatbuffers::Offset<BalanceBotFlatbuffers::RobotState> robot_state = 0,
    const char *log = nullptr) {
  auto log__ = log ? _fbb.CreateString(log) : 0;
  return BalanceBotFlatbuffers::CreateBot2Web(
      _fbb,
      ack,
      curr_enable_balancing,
      curr_pitch,
      curr_yaw,
      curr_physical,
      curr_motor_l,
      curr_motor_r,
      saved_enable_balancing,
      saved_pitch,
      saved_yaw,
      saved_physical,
      saved_motor_l,
      saved_motor_r,
      robot_state,
      log__);
}

inline bool VerifyPitchControllerState(::flatbuffers::Verifier &verifier, const void *obj, PitchControllerState type) {
  switch (type) {
    case PitchControllerState_NONE: {
      return true;
    }
    case PitchControllerState_PID: {
      return verifier.VerifyField<BalanceBotFlatbuffers::PitchPIDState>(static_cast<const uint8_t *>(obj), 0, 4);
    }
    default: return true;
  }
}

inline bool VerifyPitchControllerStateVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyPitchControllerState(
        verifier,  values->Get(i), types->GetEnum<PitchControllerState>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyYawControllerState(::flatbuffers::Verifier &verifier, const void *obj, YawControllerState type) {
  switch (type) {
    case YawControllerState_NONE: {
      return true;
    }
    case YawControllerState_PID: {
      return verifier.VerifyField<BalanceBotFlatbuffers::YawPIDState>(static_cast<const uint8_t *>(obj), 0, 4);
    }
    default: return true;
  }
}

inline bool VerifyYawControllerStateVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyYawControllerState(
        verifier,  values->Get(i), types->GetEnum<YawControllerState>(i))) {
      return false;
    }
  }
  return true;
}

}  // namespace BalanceBotFlatbuffers

#endif  // FLATBUFFERS_GENERATED_BALANCEBOT_BALANCEBOTFLATBUFFERS_H_
